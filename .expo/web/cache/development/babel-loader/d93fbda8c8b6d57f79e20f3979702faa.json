{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { getAppEventName, SharedEventEmitter } from \"../../utils/events\";\nimport { getNativeModule } from \"../../utils/native\";\nimport Transaction from \"./Transaction\";\nvar transactionId = 0;\n\nvar generateTransactionId = function generateTransactionId() {\n  return transactionId++;\n};\n\nvar TransactionHandler = function () {\n  function TransactionHandler(firestore) {\n    _classCallCheck(this, TransactionHandler);\n\n    this._pending = {};\n    this._firestore = firestore;\n    SharedEventEmitter.addListener(getAppEventName(this._firestore, 'firestore_transaction_event'), this._handleTransactionEvent.bind(this));\n  }\n\n  _createClass(TransactionHandler, [{\n    key: \"_add\",\n    value: function _add(updateFunction) {\n      var _this = this;\n\n      var id = generateTransactionId();\n      var meta = {\n        id: id,\n        updateFunction: updateFunction,\n        stack: new Error().stack.split('\\n').slice(2).join('\\n')\n      };\n      this._pending[id] = {\n        meta: meta,\n        transaction: new Transaction(this._firestore, meta)\n      };\n      return new Promise(function (resolve, reject) {\n        getNativeModule(_this._firestore).transactionBegin(id);\n\n        meta.resolve = function (r) {\n          resolve(r);\n\n          _this._remove(id);\n        };\n\n        meta.reject = function (e) {\n          reject(e);\n\n          _this._remove(id);\n        };\n      });\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove(id) {\n      getNativeModule(this._firestore).transactionDispose(id);\n      delete this._pending[id];\n    }\n  }, {\n    key: \"_handleTransactionEvent\",\n    value: function _handleTransactionEvent(event) {\n      switch (event.type) {\n        case 'update':\n          this._handleUpdate(event);\n\n          break;\n\n        case 'error':\n          this._handleError(event);\n\n          break;\n\n        case 'complete':\n          this._handleComplete(event);\n\n          break;\n      }\n    }\n  }, {\n    key: \"_handleUpdate\",\n    value: function _handleUpdate(event) {\n      var id, _this$_pending$id, meta, transaction, updateFunction, reject, finalError, updateFailed, pendingResult, possiblePromise;\n\n      return _regeneratorRuntime.async(function _handleUpdate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              id = event.id;\n\n              if (this._pending[id]) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt(\"return\", this._remove(id));\n\n            case 3:\n              _this$_pending$id = this._pending[id], meta = _this$_pending$id.meta, transaction = _this$_pending$id.transaction;\n              updateFunction = meta.updateFunction, reject = meta.reject;\n\n              transaction._prepare();\n\n              _context.prev = 6;\n              possiblePromise = updateFunction(transaction);\n\n              if (!(!possiblePromise || !possiblePromise.then)) {\n                _context.next = 12;\n                break;\n              }\n\n              finalError = new Error('Update function for `firestore.runTransaction(updateFunction)` must return a Promise.');\n              _context.next = 15;\n              break;\n\n            case 12:\n              _context.next = 14;\n              return _regeneratorRuntime.awrap(possiblePromise);\n\n            case 14:\n              pendingResult = _context.sent;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context[\"catch\"](6);\n              updateFailed = true;\n              finalError = _context.t0;\n\n            case 21:\n              if (!(updateFailed || finalError)) {\n                _context.next = 23;\n                break;\n              }\n\n              return _context.abrupt(\"return\", reject(finalError));\n\n            case 23:\n              transaction._pendingResult = pendingResult;\n              return _context.abrupt(\"return\", getNativeModule(this._firestore).transactionApplyBuffer(id, transaction._commandBuffer));\n\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, [[6, 17]], Promise);\n    }\n  }, {\n    key: \"_handleError\",\n    value: function _handleError(event) {\n      var id = event.id,\n          error = event.error;\n      var meta = this._pending[id].meta;\n\n      if (meta && error) {\n        var code = error.code,\n            message = error.message;\n        var errorWithStack = new Error(message);\n        errorWithStack.code = code;\n        errorWithStack.stack = \"Error: \" + message + \"\\n\" + meta.stack;\n        meta.reject(errorWithStack);\n      }\n    }\n  }, {\n    key: \"_handleComplete\",\n    value: function _handleComplete(event) {\n      var id = event.id;\n      var _this$_pending$id2 = this._pending[id],\n          meta = _this$_pending$id2.meta,\n          transaction = _this$_pending$id2.transaction;\n\n      if (meta) {\n        var pendingResult = transaction._pendingResult;\n        meta.resolve(pendingResult);\n      }\n    }\n  }]);\n\n  return TransactionHandler;\n}();\n\nexport { TransactionHandler as default };","map":{"version":3,"sources":["C:/Users/fong/Desktop/code-18122020-combined/node_modules/react-native-firebase/dist/modules/firestore/TransactionHandler.js"],"names":["getAppEventName","SharedEventEmitter","getNativeModule","Transaction","transactionId","generateTransactionId","TransactionHandler","firestore","_pending","_firestore","addListener","_handleTransactionEvent","bind","updateFunction","id","meta","stack","Error","split","slice","join","transaction","Promise","resolve","reject","transactionBegin","r","_remove","e","transactionDispose","event","type","_handleUpdate","_handleError","_handleComplete","_prepare","possiblePromise","then","finalError","pendingResult","updateFailed","_pendingResult","transactionApplyBuffer","_commandBuffer","error","code","message","errorWithStack"],"mappings":"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","sourcesContent":["/**\n * \n * Firestore Transaction representation wrapper\n */\nimport { getAppEventName, SharedEventEmitter } from '../../utils/events';\nimport { getNativeModule } from '../../utils/native';\nimport Transaction from './Transaction';\nlet transactionId = 0;\n/**\n * Uses the push id generator to create a transaction id\n * @returns {number}\n * @private\n */\n\nconst generateTransactionId = () => transactionId++;\n\n/**\n * @class TransactionHandler\n */\nexport default class TransactionHandler {\n  constructor(firestore) {\n    this._pending = {};\n    this._firestore = firestore;\n    SharedEventEmitter.addListener(getAppEventName(this._firestore, 'firestore_transaction_event'), this._handleTransactionEvent.bind(this));\n  }\n  /**\n   * -------------\n   * INTERNAL API\n   * -------------\n   */\n\n  /**\n   * Add a new transaction and start it natively.\n   * @param updateFunction\n   */\n\n\n  _add(updateFunction) {\n    const id = generateTransactionId(); // $FlowExpectedError: Transaction has to be populated\n\n    const meta = {\n      id,\n      updateFunction,\n      stack: new Error().stack.split('\\n').slice(2).join('\\n')\n    };\n    this._pending[id] = {\n      meta,\n      transaction: new Transaction(this._firestore, meta)\n    }; // deferred promise\n\n    return new Promise((resolve, reject) => {\n      getNativeModule(this._firestore).transactionBegin(id);\n\n      meta.resolve = r => {\n        resolve(r);\n\n        this._remove(id);\n      };\n\n      meta.reject = e => {\n        reject(e);\n\n        this._remove(id);\n      };\n    });\n  }\n  /**\n   * Destroys a local instance of a transaction meta\n   *\n   * @param id\n   * @private\n   */\n\n\n  _remove(id) {\n    getNativeModule(this._firestore).transactionDispose(id);\n    delete this._pending[id];\n  }\n  /**\n   * -------------\n   *    EVENTS\n   * -------------\n   */\n\n  /**\n   * Handles incoming native transaction events and distributes to correct\n   * internal handler by event.type\n   *\n   * @param event\n   * @returns {*}\n   * @private\n   */\n\n\n  _handleTransactionEvent(event) {\n    // eslint-disable-next-line default-case\n    switch (event.type) {\n      case 'update':\n        this._handleUpdate(event);\n\n        break;\n\n      case 'error':\n        this._handleError(event);\n\n        break;\n\n      case 'complete':\n        this._handleComplete(event);\n\n        break;\n    }\n  }\n  /**\n   * Handles incoming native transaction update events\n   *\n   * @param event\n   * @private\n   */\n\n\n  async _handleUpdate(event) {\n    const {\n      id\n    } = event; // abort if no longer exists js side\n\n    if (!this._pending[id]) return this._remove(id);\n    const {\n      meta,\n      transaction\n    } = this._pending[id];\n    const {\n      updateFunction,\n      reject\n    } = meta; // clear any saved state from previous transaction runs\n\n    transaction._prepare();\n\n    let finalError;\n    let updateFailed;\n    let pendingResult; // run the users custom update functionality\n\n    try {\n      const possiblePromise = updateFunction(transaction); // validate user has returned a promise in their update function\n      // TODO must it actually return a promise? Can't find any usages of it without one...\n\n      if (!possiblePromise || !possiblePromise.then) {\n        finalError = new Error('Update function for `firestore.runTransaction(updateFunction)` must return a Promise.');\n      } else {\n        pendingResult = await possiblePromise;\n      }\n    } catch (exception) {\n      // exception can still be falsey if user `Promise.reject();` 's with no args\n      // so we track the exception with a updateFailed boolean to ensure no fall-through\n      updateFailed = true;\n      finalError = exception;\n    } // reject the final promise and remove from native\n    // update is failed when either the users updateFunction\n    // throws an error or rejects a promise\n\n\n    if (updateFailed || finalError) {\n      // $FlowExpectedError: Reject will always be present\n      return reject(finalError);\n    } // capture the resolved result as we'll need this\n    // to resolve the runTransaction() promise when\n    // native emits that the transaction is final\n\n\n    transaction._pendingResult = pendingResult; // send the buffered update/set/delete commands for native to process\n\n    return getNativeModule(this._firestore).transactionApplyBuffer(id, transaction._commandBuffer);\n  }\n  /**\n   * Handles incoming native transaction error events\n   *\n   * @param event\n   * @private\n   */\n\n\n  _handleError(event) {\n    const {\n      id,\n      error\n    } = event;\n    const {\n      meta\n    } = this._pending[id];\n\n    if (meta && error) {\n      const {\n        code,\n        message\n      } = error; // build a JS error and replace its stack\n      // with the captured one at start of transaction\n      // so it's actually relevant to the user\n\n      const errorWithStack = new Error(message); // $FlowExpectedError: code is needed for Firebase errors\n\n      errorWithStack.code = code; // $FlowExpectedError: stack should be a stack trace\n\n      errorWithStack.stack = `Error: ${message}\\n${meta.stack}`; // $FlowExpectedError: Reject will always be present\n\n      meta.reject(errorWithStack);\n    }\n  }\n  /**\n   * Handles incoming native transaction complete events\n   *\n   * @param event\n   * @private\n   */\n\n\n  _handleComplete(event) {\n    const {\n      id\n    } = event;\n    const {\n      meta,\n      transaction\n    } = this._pending[id];\n\n    if (meta) {\n      const pendingResult = transaction._pendingResult; // $FlowExpectedError: Resolve will always be present\n\n      meta.resolve(pendingResult);\n    }\n  }\n\n}"]},"metadata":{},"sourceType":"module"}