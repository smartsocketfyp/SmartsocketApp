{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport FieldPath from \"../FieldPath\";\nimport { isObject, isString } from \"../../../utils\";\n\nvar buildFieldPathData = function buildFieldPathData(segments, value) {\n  if (segments.length === 1) {\n    return _defineProperty({}, segments[0], value);\n  }\n\n  return _defineProperty({}, segments[0], buildFieldPathData(segments.slice(1), value));\n};\n\nexport var mergeFieldPathData = function mergeFieldPathData(data, segments, value) {\n  if (segments.length === 1) {\n    return _objectSpread(_objectSpread({}, data), {}, _defineProperty({}, segments[0], value));\n  }\n\n  if (data[segments[0]]) {\n    return _objectSpread(_objectSpread({}, data), {}, _defineProperty({}, segments[0], mergeFieldPathData(data[segments[0]], segments.slice(1), value)));\n  }\n\n  return _objectSpread(_objectSpread({}, data), {}, _defineProperty({}, segments[0], buildFieldPathData(segments.slice(1), value)));\n};\nexport var parseUpdateArgs = function parseUpdateArgs(args, methodName) {\n  var data = {};\n\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error(methodName + \" failed: If using a single update argument, it must be an object.\");\n    }\n\n    var _args = _slicedToArray(args, 1);\n\n    data = _args[0];\n  } else if (args.length % 2 === 1) {\n    throw new Error(methodName + \" failed: The update arguments must be either a single object argument, or equal numbers of key/value pairs.\");\n  } else {\n    for (var i = 0; i < args.length; i += 2) {\n      var key = args[i];\n      var value = args[i + 1];\n\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FieldPath) {\n        data = mergeFieldPathData(data, key._segments, value);\n      } else {\n        throw new Error(methodName + \" failed: Argument at index \" + i + \" must be a string or FieldPath\");\n      }\n    }\n  }\n\n  return data;\n};","map":{"version":3,"sources":["C:/Users/fong/Desktop/code-18122020-combined/node_modules/react-native-firebase/dist/modules/firestore/utils/index.js"],"names":["FieldPath","isObject","isString","buildFieldPathData","segments","value","length","slice","mergeFieldPathData","data","parseUpdateArgs","args","methodName","Error","i","key","_segments"],"mappings":";;;;;;;AAAA,OAAOA,SAAP;AACA,SAASC,QAAT,EAAmBC,QAAnB;;AAEA,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,CAACC,QAAD,EAAWC,KAAX,EAAqB;AAC9C,MAAID,QAAQ,CAACE,MAAT,KAAoB,CAAxB,EAA2B;AACzB,+BACGF,QAAQ,CAAC,CAAD,CADX,EACiBC,KADjB;AAGD;;AAED,6BACGD,QAAQ,CAAC,CAAD,CADX,EACiBD,kBAAkB,CAACC,QAAQ,CAACG,KAAT,CAAe,CAAf,CAAD,EAAoBF,KAApB,CADnC;AAGD,CAVD;;AAaA,OAAO,IAAMG,kBAAkB,GAAG,SAArBA,kBAAqB,CAACC,IAAD,EAAOL,QAAP,EAAiBC,KAAjB,EAA2B;AAC3D,MAAID,QAAQ,CAACE,MAAT,KAAoB,CAAxB,EAA2B;AACzB,2CAAYG,IAAZ,2BACGL,QAAQ,CAAC,CAAD,CADX,EACiBC,KADjB;AAGD;;AAED,MAAII,IAAI,CAACL,QAAQ,CAAC,CAAD,CAAT,CAAR,EAAuB;AACrB,2CAAYK,IAAZ,2BACGL,QAAQ,CAAC,CAAD,CADX,EACiBI,kBAAkB,CAACC,IAAI,CAACL,QAAQ,CAAC,CAAD,CAAT,CAAL,EAAoBA,QAAQ,CAACG,KAAT,CAAe,CAAf,CAApB,EAAuCF,KAAvC,CADnC;AAGD;;AAED,yCAAYI,IAAZ,2BACGL,QAAQ,CAAC,CAAD,CADX,EACiBD,kBAAkB,CAACC,QAAQ,CAACG,KAAT,CAAe,CAAf,CAAD,EAAoBF,KAApB,CADnC;AAGD,CAhBM;AAiBP,OAAO,IAAMK,eAAe,GAAG,SAAlBA,eAAkB,CAACC,IAAD,EAAOC,UAAP,EAAsB;AACnD,MAAIH,IAAI,GAAG,EAAX;;AAEA,MAAIE,IAAI,CAACL,MAAL,KAAgB,CAApB,EAAuB;AACrB,QAAI,CAACL,QAAQ,CAACU,IAAI,CAAC,CAAD,CAAL,CAAb,EAAwB;AACtB,YAAM,IAAIE,KAAJ,CAAaD,UAAb,uEAAN;AACD;;AAHoB,+BAKZD,IALY;;AAKpBF,IAAAA,IALoB;AAMtB,GAND,MAMO,IAAIE,IAAI,CAACL,MAAL,GAAc,CAAd,KAAoB,CAAxB,EAA2B;AAChC,UAAM,IAAIO,KAAJ,CAAaD,UAAb,iHAAN;AACD,GAFM,MAEA;AACL,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAAI,CAACL,MAAzB,EAAiCQ,CAAC,IAAI,CAAtC,EAAyC;AACvC,UAAMC,GAAG,GAAGJ,IAAI,CAACG,CAAD,CAAhB;AACA,UAAMT,KAAK,GAAGM,IAAI,CAACG,CAAC,GAAG,CAAL,CAAlB;;AAEA,UAAIZ,QAAQ,CAACa,GAAD,CAAZ,EAAmB;AACjBN,QAAAA,IAAI,CAACM,GAAD,CAAJ,GAAYV,KAAZ;AACD,OAFD,MAEO,IAAIU,GAAG,YAAYf,SAAnB,EAA8B;AACnCS,QAAAA,IAAI,GAAGD,kBAAkB,CAACC,IAAD,EAAOM,GAAG,CAACC,SAAX,EAAsBX,KAAtB,CAAzB;AACD,OAFM,MAEA;AACL,cAAM,IAAIQ,KAAJ,CAAaD,UAAb,mCAAqDE,CAArD,oCAAN;AACD;AACF;AACF;;AAED,SAAOL,IAAP;AACD,CA3BM","sourcesContent":["import FieldPath from '../FieldPath';\nimport { isObject, isString } from '../../../utils';\n\nconst buildFieldPathData = (segments, value) => {\n  if (segments.length === 1) {\n    return {\n      [segments[0]]: value\n    };\n  }\n\n  return {\n    [segments[0]]: buildFieldPathData(segments.slice(1), value)\n  };\n}; // eslint-disable-next-line import/prefer-default-export\n\n\nexport const mergeFieldPathData = (data, segments, value) => {\n  if (segments.length === 1) {\n    return { ...data,\n      [segments[0]]: value\n    };\n  }\n\n  if (data[segments[0]]) {\n    return { ...data,\n      [segments[0]]: mergeFieldPathData(data[segments[0]], segments.slice(1), value)\n    };\n  }\n\n  return { ...data,\n    [segments[0]]: buildFieldPathData(segments.slice(1), value)\n  };\n};\nexport const parseUpdateArgs = (args, methodName) => {\n  let data = {};\n\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error(`${methodName} failed: If using a single update argument, it must be an object.`);\n    }\n\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error(`${methodName} failed: The update arguments must be either a single object argument, or equal numbers of key/value pairs.`);\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FieldPath) {\n        data = mergeFieldPathData(data, key._segments, value);\n      } else {\n        throw new Error(`${methodName} failed: Argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n\n  return data;\n};"]},"metadata":{},"sourceType":"module"}